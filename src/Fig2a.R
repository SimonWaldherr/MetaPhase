#!/net/gs/vol3/software/modules-sw/R/2.15.1/Linux/RHEL6/x86_64/bin/Rscript
# The above 'shebang' allows this file to be self-executing
#
# This script was auto-generated by MetaPhase, in the function MetaAssembly::DrawFigure2a().
# It uses the data files Fig2a.node_chart and Fig2a.edge_chart.


library( igraph )
library( RColorBrewer )

print( Sys.time() )

node.chart <- read.table( 'Fig2a.node_chart', header=TRUE )
edge.chart <- read.table( 'Fig2a.edge_chart', header=TRUE )


# Make a matrix for the edge list, and use this to load in the graph.
edge.list <- cbind( as.character(edge.chart$N1), as.character(edge.chart$N2) )
graph <- graph.edgelist( edge.list, directed=FALSE )
# Read in the data about nodes/contigs.  The data has to be remapped by node name.
node.names <- V(graph)$name
N.nodes <- length( node.names )
#node.data <- t( sapply( node.names, function(x) node.chart[node.chart$NAME==x,] ) )

node.sizes <- sapply( node.names, function(x) node.chart[node.chart$NAME==x,'LENGTH'] )
V(graph)$size <- sqrt( node.sizes ) * 0.01



# Get an array of colors for each node according to the node/contig's cluster.
palette <- c( brewer.pal( 3, 'Pastel1' ), brewer.pal( 9, 'Set1' ) )
node.colors <- sapply( node.names, function(x) palette[ node.chart[node.chart$NAME==x,'TRUTH'] + 1 ] ) # +1 for one-indexing
V(graph)$color <- node.colors



edge.weights <- sqrt( edge.chart$NLINKS * 0.5 )

# Load edges' cluster IDs and convert them to colors.  This requires a modified palette with an extra color for unclustered edges (-1).
palette2 <- c( 'gray20', palette )
edge.colors <- palette2[ edge.chart$TRUTH + 2 ] # +1 for one-indexing, +1 for the '-1' entries




print( Sys.time() )

lay <- layout.fruchterman.reingold( graph, niter=500, repulserad=N.nodes*N.nodes*N.nodes^0.2 )

print( Sys.time() )

png( file='~/public_html/graph.MY.png', width=1200, height=1200 )

plot( graph, layout=lay, vertex.label=NA, edge.width=edge.weights, edge.color=edge.colors )
invisible( dev.off() )

print( Sys.time() )

